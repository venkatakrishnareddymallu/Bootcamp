(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.g1 = global.g1 || {})));
}(this, (function (exports) { 'use strict';

var version = "0.16.2";

function namespace(search, name) {
  // Return an object with all keys in search that begin with `<name>:` or
  // do not have a `:` in them.
  // If name is false-y, return search
  if (!name)
    return search
  var result = {};
  for (var key in search) {
    var parts = key.split(':');
    if (parts.length == 1)
      result[parts[0]] = search[key];
    else if (parts[0] === name)
      result[parts[1]] = search[key];
  }
  return result
}

// state_transition[old_state][current_type] -> new_state
// type: undefined and type: null are mapped to state 'null', i.e. missing values
var state_transitions = {
  'null': {
    'null': { state: 'null' },
    'date': { state: 'date' },
    'number': { state: 'number' },
    'boolean': { state: 'boolean' },
    'string': { state: 'string' },
    'object': { state: 'object' },
    'mixed': { state: 'mixed', end: true }
  },
  'date': {
    'null': { state: 'date' },
    'undefined': { state: 'date' },
    'date': { state: 'date' },
    'default': { state: 'mixed', end: true }
  },
  'number': {
    'null': { state: 'number' },
    'undefined': { state: 'number' },
    'number': { state: 'number' },
    'default': { state: 'mixed', end: true }
  },
  'boolean': {
    'null': { state: 'boolean' },
    'undefined': { state: 'boolean' },
    'boolean': { state: 'boolean' },
    'default': { state: 'mixed', end: true }
  },
  'string': {
    'null': { state: 'string' },
    'undefined': { state: 'string' },
    'string': { state: 'string' },
    'default': { state: 'mixed', end: true }
  },
  'object': {
    'null': { state: 'object' },
    'object': { state: 'object' },
    'undefined': { state: 'object' },
    'default': { state: 'mixed', end: true }
  },
  'mixed': {
    'default': { state: 'mixed', end: true }
  }
};


function types(data, options) {
  var result = {};
  if (!data || !data.length)
    return result

  options = options || {};
  options.convert = options.convert || false;
  options.limit = options.limit || 1000;
  var limit = (options.limit < data.length) ? options.limit : data.length;
  var ignore = options.ignore = options.ignore || [null, undefined];
  var columns = Object.keys(data[0]);

  for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
    var column = columns[columnIndex];
    var result_type = 'null';
    for (var index = 0; index < limit; index++) {
      var row = data[index];
      var value = row[column];

      if (columnIndex == 0) {
        Object.keys(data[index]).forEach(function (value) {
          if (columns.indexOf(value) == -1)
            columns.push(value);
        });
      }

      // Ignore if the value is missing
      if (!(column in row))
        continue
      // Ignore values that are in the ignore list
      if (ignore.indexOf(value) >= 0)
        continue
      // Identify type (date, object, number, boolean, string, undefined, null)
      var type = typeof value;
      if (value === undefined || value === null)
        type = 'null';
      else if (type == 'object' && !isNaN(Date.parse(value)))
        type = 'date';
      else if (options.convert) {
        // We use parseFloat AND isFinite because
        // parseFloat('2018-01') is 2018 but isFinite('2018-01') is false
        // Also, 'NaN', 'Infinity' and '-Infinity' should be treated as numbers
        if ((!isNaN(parseFloat(value)) && isFinite(value)) || ['NaN', 'Infinity', '-Infinity'].indexOf(value) >= 0)
          type = 'number';
        else if (!isNaN(Date.parse(value)))
          type = 'date';
        else if (['true', 'false'].indexOf(value) != -1)
          type = 'boolean';
      }

      // Apply the state change
      var state_transition = state_transitions[type];
      var change = state_transition[result_type] || state_transition['default'];
      result_type = change['state'];
      if (change['end'])
        break
    }
    result[column] = result_type;
  }
  return result
}

function isEqual(value, compare_with, criteria_satisfied) {
  // to handle: ( ...Shape!&... ) or ( ...&Shape&... )
  if (!value) {
    return criteria_satisfied ? (compare_with == null) : (compare_with != null)
  }
  return value.indexOf(compare_with) != -1 ? !criteria_satisfied : criteria_satisfied
}

function greater_than(value, compare_with, include_equals) {
  if ((isNaN(compare_with) && Date.parse(compare_with))) {
    compare_with = Date.parse(compare_with);
  }
  if ((isNaN(value) && Date.parse(value))) {
    value = Date.parse(value);
  }
  return include_equals ? (compare_with >= value) : (compare_with > value)
}
var operators = {
  '=': function (value, compare_with) {
    return isEqual(value, compare_with, false)
  },
  '!': function (value, compare_with) {
    return isEqual(value, compare_with, true)
  },
  '>': function (value, compare_with) {
    return greater_than(value, compare_with, false)
  },
  '<': function (value, compare_with) {
    return greater_than(compare_with, value, false)
  },
  '>~': function (value, compare_with) {
    return greater_than(value, compare_with, true)
  },
  '<~': function (value, compare_with) {
    return greater_than(compare_with, value, true)
  },
  '~': function (value, compare_with) {
    return isEqual(compare_with, value[0], false)
  },
  '!~': function (value, compare_with) {
    return isEqual(compare_with, value[0], true)
  }
};

var sorting = {
  'string': function (value, compare_with, order) {
    if (!order) order = 'asc';
    // swap if 'desc'
    if (order == 'desc')
      value = [compare_with, compare_with = value][0];

    return value.localeCompare(compare_with)
  },
  'number': function (value, compare_with, order) {
    if (!order) order = 'asc';
    // swap if 'desc'
    if (order == 'desc')
      value = [compare_with, compare_with = value][0];

    return value - compare_with
  }
};

function clone_pluck(source, include_keys, exclude_keys) {
  if (include_keys.length == 0) include_keys = Object.keys(source);
  var new_obj = {};
  include_keys.forEach(function (key) {
    if (exclude_keys.indexOf(key) < 0) new_obj[key] = source[key];
  });
  return new_obj
}



function datafilter(data, filters, dataset_name) {
  filters = filters || [];

  var result = data;
  var operator, value;

  // url namespace sanitize
  filters = namespace(filters, dataset_name);

  var data_types = types(data, { convert: true });

  // apply WHERE clause
  for (var key in filters) {
    if (key[0] == '_') continue
    var operator_index = (key.match(/(!|>|>~|<|<~|~|!~)$/)) ? key.match(/(!|>|>~|<|<~|~|!~)$/).index : key.length;
    operator = (key.slice(operator_index) != '') ? key.slice(operator_index) : '=';
    value = (filters[key][0] != "") ? filters[key] : null;

    var col = key.slice(0, operator_index);
    if (data_types[col] == 'number') {
      value = value.map(function(val) { return parseFloat(val)});
    } else if (data_types[col] == 'boolean') {
      value = value.map(function(val){ return String(val) == 'true' ? true : false});
    } else if (data_types[col] == 'date') {
      value = value.map(function(val) { return Date.parse(val) });
    }

    result = result.filter(function (row) {
      return (typeof row[col] != 'undefined') ? operators[operator](value, row[col]) : true
    });
  }

  var offset = parseInt(filters['_offset']) || 0;
  var limit = parseInt(filters['_limit']) || 1000;

  result = result.slice(offset, (offset + limit));

  // apply SELECT clause
  if (filters['_c']) {
    var exclude_cols = [], include_cols = [];
    filters['_c'].forEach(function (column) {
      column[0] == '-' ? exclude_cols.push(column.slice(1)) : include_cols.push(column);
    });
    result = result.map(function (row) {
      return clone_pluck(row, include_cols, exclude_cols)
    });
  }

  if (filters['_sort']) {
    result.sort(function (a, b) {
      var swap_rows = false;
      filters['_sort'].forEach(function (sort) {
        var order = (sort[0] == '-') ? 'desc' : 'asc';
        if (sort[0] == '-') sort = sort.substr(1);
        if (typeof a[sort] == 'undefined') return
        // if sort.column evaluates to false, it will proceed with evaluating || expression
        var type = (isNaN(a[sort])) ? 'string' : 'number';
        swap_rows = swap_rows || sorting[type](a[sort], b[sort], order);
      });
      return swap_rows
    });
  }

  return result
}

/*
  var search = g1.fuzzysearch(data, options)
  // Specify keys in data as a list of column names or functions
  options.keys = [ 'col1', function(v) { return v.info.name } ]
  // Specify max results to return. Default: 100
  options.limit = 10
  // Case sensitive search. Default: false
  options.case = True
*/
function fuzzysearch (data, options) {
  options = options || {};
  // "values" is the string array with the text to search
  var values;
  // If no options.keys are provided, use the raw data as-is
  if (!options.keys)
    values = data;
  // Else, join the provided keys
  else
    values = data.map(function(row) {
      return options.keys.map(function(v) {
        return typeof v == 'function' ? v(row) : row[v]
      }).join(' ')
    });
  var limit = options.limit || 100;
  var flags = options.case ? '' : 'i';
  // TODO: document these options once stabilized
  var depth = options.depth || 10;
  var escape = options.escape || true;

  return function(text) {
    var results = [],             // Final results
        vals = values.slice(),    // Values to search. Crosses off matches to avoid duplication
        re;
    // Trim the search text
    text = text.replace(/^\s/, '').replace(/\s$/, '');
    if (escape)
      text = text.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');

    // 1. Match full phrase
    re = new RegExp(text.replace(/\s+/, '\\s+'), flags);
    vals.forEach(function (v, i) {
      if (v && re.test(v)) { results.push(data[i]); vals[i] = ''; }
    });
    if (depth <= 1 || results.length >= limit) return results.slice(0, limit)

    // 2. Match words in order
    re = new RegExp(text.replace(/\s+/, '.*'), flags);
    vals.forEach(function (v, i) {
      if (v && re.test(v)) { results.push(data[i]); vals[i] = ''; }
    });
    if (depth <= 2 || results.length >= limit) return results.slice(0, limit)

    // 3. Match words in any order
    re = text.split(/\s+/).map(function (word) { return new RegExp(word, flags) });
    vals.forEach(function (v, i) {
      if (v && re.every(function (word) { return word.test(v) })) { results.push(data[i]); vals[i] = ''; }
    });
    if (depth <= 3 || results.length >= limit) return results.slice(0, limit)

    // 4. Match partial words in any order
    re = text.split(/\s+/).map(function (word) { return new RegExp(word.replace(/(.)/g, '$&[\\S]*'), flags) });
    vals.forEach(function (v, i) {
      if (v && re.every(function (word) { return word.test(v) })) { results.push(data[i]); vals[i] = ''; }
    });

    // 5. Match characters in order
    re = new RegExp(text.replace(/(.)/g, '$&.*'), flags);
    vals.forEach(function (v, i) {
      if (v && re.test(v)) { results.push(data[i]); vals[i] = ''; }
    });
    if (depth <= 4 || results.length >= limit) return results.slice(0, limit)

    return results.slice(0, limit)
  }
}

/*
## scale

Converts a configuration into a d3 scale function. This is used to extract a
different value for each data point. For example:

```js
var color_scale = g1.scale({
  metric: 'age',
  scheme: 'RdYlGn'
}, data)
// Returns a color scale that maps the age column to the red - yellow - green color scheme
```

### scale attributes

- metric can be one of:
  - string: column name
  - `function(d, i)` that returns a value for each item in the data
- scheme: color scheme to interpolate to
- scale: d3 scale to use. Defaults to linear
- range: set the range of the scale
- domain: override the domain (which defaults to the extent of the data metric)
*/

function scale (data, config) {
  return function(val) {
    var result, scale, color;

    var metricFormula = typeof config.metric == 'function' ? config.metric
      : function(d) { return d[config.metric]};

    if (config.scheme) {
      color = config.scheme;
      if (color.lastIndexOf('scheme', 0) !== 0) {
        color = 'interpolate' + color;
      }
    }

    if (config.scale) {
      scale = config.scale.replace(/\w+/g,
        function(w){
          return w[0].toUpperCase() + w.slice(1).toLowerCase()
        });
    } else if (color) {
      scale = 'Sequential';
    } else {
      scale = 'Linear';
    }

    var domain = config.domain || d3.extent(data, metricFormula);
    if (color) {
      result = d3['scale' + scale](d3[color])
        .domain(domain);
    } else if (config.range) {
      result = d3['scale' + scale]()
        .domain(domain)
        .range(config.range);
    }

    return result(metricFormula(val))
  }
}

/* This is extracted from

https://github.com/d3/d3-interpolate/blob/master/src/transform/parse.js
https://github.com/d3/d3-interpolate/blob/master/src/transform/decompose.js

TODO: import parseSvg directly from d3 instead of re-writing.

*/
var svgNode;
var degrees = 180 / Math.PI;
var identity = {translateX: 0, translateY: 0};

function parseSvg(value) {
  if (value == null) return identity
  if (!svgNode) svgNode = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  svgNode.setAttribute('transform', value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f)
}

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  }
}

/* globals d3 */

function SanddanceException(message, options) {
  this.message = message;
  this.options = options;
}
function pop(dict, key, value) {
  if (key in dict) {
    value = dict[key];
    delete dict[key];
  }
  return value
}
// A replacement for Object.assign()
function copy(target) {
  for (var i=1, l=arguments.length; i<l; i++) {
    var source = arguments[i];
    for (var key in source)
      target[key] = source[key];
  }
  return target
}
// Distance between two points
function dist(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy)
}
// Return the indices of data when data is sorted by a column (str or fn),
// with order specified by ascending=true (default) or false
function sort(data, column, ascending) {
  // indices[i] will give us the sorted position of the i-th item
  var indices = data.map(function (d, i) { return i });
  if (column) {
    // items is a list of [sort_value, index] which we use for a stable sort
    var items = data.map(typeof column == 'function' ?
      function (d, i) { return [column(d), i] } :
      function (d, i) { return [d[column], i] }
    );
    // sort the indices using a stable sort
    indices.sort(function (a, b) {
      var val1 = items[a][0],
          val2 = items[b][0];
      return val1 < val2 ? -1 : val1 > val2 ? +1 : items[a][1] - items[b][1]
    });
    // invert the indices in ascending or descending order
    ascending = !ascending && typeof ascending != 'undefined';
    for (var i = 0, l = indices.length, inv = []; i < l; i++)
      inv[indices[i]] = ascending ? i : l - i - 1;
    indices = inv;
  }
  return indices
}


// If an options value is an object, treat it as a scale configuration.
// Replace it with the scale function
function update_scale(data, options) {
  for (var key in options)
    if (typeof options[key] == 'object')
      options[key] = scale(data, options[key]);
  return options
}

var namespace$1 = '.sanddance';
var layout_map = {
  grid: sanddance_grid,
  hexpack: sanddance_hexpack,
  spiral: sanddance_spiral
};

function sanddance(attrs, options) {
  options = options || {};
  var dispatch = d3.dispatch('init', 'start', 'end');
  var layout_props;
  if (options.layout) {
    layout_props = layout_map[options.layout](attrs, options);
    attrs = layout_props.attrs;
    options = layout_props.options;
  }
  var duration = options.duration;
  var speed = options.speed;
  var delay = options.delay || 0;
  var easing = options.easing || d3.easeLinear;
  var filter = options.filter;
  var x = options.x;
  var y = options.y;

  var result = function (selection) {
    dispatch.call('init', selection);
    var filtered = filter ? selection.filter(filter) : selection;

    var transition = filtered.transition()
      .ease(easing);

    if (x || y) {
      var x_fn = typeof x == 'function' ? x : function () { return x };
      var y_fn = typeof y == 'function' ? y : function () { return y };
      transition.attr('transform', function(d, i) {
        var x = x_fn(d, i);
        var y = y_fn(d, i);
        this.dataset['_sd_x'] = x;
        this.dataset['_sd_y'] = y;
        return 'translate(' + x + ',' + y + ')'
      });
    }

    for (var key in attrs)
      transition = transition.attr(key, attrs[key]);

    // Note: duration = 0 is a valid duration
    if ('duration' in options)
      transition = transition.duration(duration);
    else if (speed)
      transition = transition.duration(function (d) {
        var transform = parseSvg(this.getAttribute('transform'));
        var x1 = transform.translateX;
        var y1 = transform.translateY;
        // TODO (Anand): Need a better way of identifying where the element will be
        // across transforms and setting x, y
        var x2 = this.dataset['_sd_x'];
        var y2 = this.dataset['_sd_y'];
        var distance = dist(x1, y1, x2, y2);
        var _speed = typeof speed == 'function' ? speed(d) : speed;
        return distance / _speed * 1000
      });

    if (delay)
      transition = transition.delay(function (d) {
        return typeof delay == 'function' ? delay(d) : delay
      });

    // Set up event handling.
    // sanddance.on('start') is triggered when the first transition begins
    var count_end = filtered.size(),
        count_start = 0;
    transition.on('start.count', function () {
      if (count_start === 0)
        dispatch.call('start', selection);
      count_start++;
    });
    // sanddance.on('end') is triggered when the last transition stops (ends / interrupted)
    transition.on('end interrupt', function () {
      count_end--;
      if (count_end > 0)
        return
      else if (count_end === 0)
        return dispatch.call('end', selection)
      else
        throw new SanddanceException('sanddance: Invalid count: ' + count_end, options)
    });
  };
  result.on = function (event, callback) {
    dispatch.on(event + namespace$1, callback);
    return result
  };
  // Returns a new sanddance with updated attributes
  result.update = function (update_attrs, update_options) {
    return sanddance(copy({}, attrs, update_attrs), copy({}, options, update_options))
  };
  return result
}

sanddance.chain = function () {
  for (var i = 0, l = arguments.length - 1; i < l; i++) {
    (function (prev, next) {
      prev.on('end' + namespace$1, function () { this.call(next); });
    })(arguments[i], arguments[i + 1]);
  }
  return arguments[0]
};

function sanddance_grid (attrs, options) {
  var data = options.data;
  var width = options.width;
  var height = options.height;
  var area = width * height / data.length;
  var element_width = Math.sqrt(area);
  var elements_per_row = Math.ceil(width / element_width);
  var num_rows = Math.ceil(data.length / elements_per_row);
  var element_height = element_width * num_rows;
  var filter = options.filter;
  data = filter ? data.filter(function (d, i) { return filter(d, i) }) : data;
  var indices = sort(data, options.sort, options.ascending);

  attrs.transform = function (d, i) {
    // TODO: pre-compute these into a pos[] array
    i = indices[i];
    var col = i % elements_per_row;
    var row = Math.floor(i / elements_per_row);
    var x = this.dataset['_sd_x'] = col * element_width;
    var y = this.dataset['_sd_y'] = element_height - ((row + 1) * element_width);
    return 'translate(' + x + ',' + y + ')'
  };
  return {attrs: update_scale(data, attrs), options: options}
}

function sanddance_hexpack (attrs, options) {
  var data = options.data;
  var filter = options.filter;
  data = filter ? data.filter(function (d, i) { return filter(d, i) }) : data;
  var indices = sort(data, options.sort, options.sort_ascending);
  var count = data.length;
  var pos = [[0, 0]],
      l = 1,    // level
      n = 0,    // number of items filled so far
      i;
  while (n < count) {
    for (i = 0;  i >= 1 - l; i--) pos.push([l, i]);       // top-right
    for (i = l;  i >= 1;     i--) pos.push([i, -l]);      // top
    for (i = 0;  i >= 1 - l; i--) pos.push([i, -l - i]);  // top left
    for (i = 0;  i <= l - 1; i++) pos.push([-l, i]);      // bottom left
    for (i = -l; i <= -1;    i++) pos.push([i, l]);       // bottom
    for (i = 0;  i <= l - 1; i++) pos.push([i, l - i]);   // bottom right
    n += l * 6;    // increment number of items filled
    l++;           // move to next level
  }
  // Pre-compute positions
  var width = options.width;
  var height = options.height;
  var diameter = 2 * l - 1;
  var size_x = width / diameter;
  var size_y = height / diameter;
  var cos = size_x * Math.cos(Math.PI * 60 / 180);
  var sin = size_y * Math.sin(Math.PI * 60 / 180);
  pos = pos.slice(0, count).map(function (row) {
    return [row[0] * size_x + row[1] * cos + width / 2, row[1] * sin + height / 2]
  });
  attrs.transform = function (d, i) {
    i = indices[i];
    var p = pos[i];
    return 'translate(' + p[0] + ',' + p[1] + ')'
  };
  return {attrs: update_scale(data, attrs), options: options}
}

function sanddance_spiral (attrs, options) {
  var data = options.data;
  var filter = options.filter;
  data = filter ? data.filter(function (d, i) { return filter(d, i) }) : data;
  var indices = sort(data, options.sort, options.sort_ascending);
  var radius = pop(options, 'spiral_size');
  var angle = pop(options, 'spiral_angle') * Math.PI / 180;
  var pos = data.map(function (d, i) {
    return [
      (i * radius) * Math.cos(i * angle),
      (i * radius) * Math.sin(i * angle)
    ]
  });
  attrs.transform = function (d, i) {
    i = indices[i];
    return 'translate(' + pos[i][0] + ',' + pos[i][1] + ')'
  };
  return {attrs: update_scale(data, attrs), options: options}
}

/*
  url.parse() provides results consistent with window.location.

  0 href                Full URL source
  1 protocol            http, https, etc
  2 origin              username:password@hostname:port
  4 username            username
  5 password            password
  - host                NOT IMPLEMENTED
  6 hostname            hostname
  7 port                port
  9 pathname            full path, excluding hash
  12 search              search parameters
  13 hash                url fragment

  The following are not part of window.location, but provided anyway.

  3 userinfo            username:password
  8 relative:           Everything after origin
  10 directory:          Directory part of pathname
  11 file:               File part of pathname
    - searchKey           search as an ordered dict of strings
    - searchList          search as an ordered dict of arrays
  */

var
    _url_parse_key    = ['href','protocol','origin','userinfo','username','password','hostname','port','relative','pathname','directory','file','search','hash'],
    _url_parse_qname  = ['searchKey', 'searchList'],
    _url_parse_strict = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,  // eslint-disable-line
    _url_parse_search = /(?:^|&)([^&=]*)=?([^&]*)/g;

var _decode_uri_component = function(s) { return decodeURIComponent(s.replace(/\+/g, '%20')) },
    _encode_uri_component = encodeURIComponent;

function parse(str) {
  /* Based on parseUri 1.2.2: http://blog.stevenlevithan.com/archives/parseuri
    MIT License
  */
  var uri = {
        toString: unparse,
        join: join,
        update: update
      },
      m   = _url_parse_strict.exec(str || ''),
      i   = 14;

  while (i--) uri[_url_parse_key[i]] = m[i] || '';

  var search_key = uri[_url_parse_qname[0]] = {},
      search_list = uri[_url_parse_qname[1]] = {};
  uri[_url_parse_key[12]].replace(_url_parse_search, function ($0, key, val) {
    if (key) {
      key = _decode_uri_component(key);
      val = _decode_uri_component(val);
      search_key[key] = val;
      search_list[key] = search_list[key] || [];
      search_list[key].push(val);
    }
  });

  return uri
}


// Converts the URL parts back into the original URL.
function unparse(self) {
  self = self || this;
  var protocol    = self[_url_parse_key[1]] || 'http',
      username    = self[_url_parse_key[4]],
      password    = self[_url_parse_key[5]],
      hostname    = self[_url_parse_key[6]],
      port        = self[_url_parse_key[7]],
      pathname    = self[_url_parse_key[9]],
      search      = self[_url_parse_key[12]],
      hash        = self[_url_parse_key[13]],
      search_key  = self[_url_parse_qname[0]],
      search_list = self[_url_parse_qname[1]],
      parts = hostname ? [protocol, '://'] : [],
      qparts = [],
      key, vals, i, l;
  if (username) {
    parts.push(username);
    if (password) parts.push(':', password);
    parts.push('@');
  }
  parts.push(hostname);
  if (port) parts.push(':', port);
  parts.push(pathname || (hostname ? '/' : ''));
  if (search) {
    parts.push('?', search);
  } else {
    if (search_list) {
      for (key in search_list) {
        for (i=0, vals=search_list[key], l=vals.length; i<l; i++) {
          qparts.push(_encode_uri_component(key) + '=' + _encode_uri_component(vals[i]));
        }
        if (!l) qparts.push(key);
      }
    } else if (search_key) {
      for (key in search_key) {
        qparts.push(_encode_uri_component(key) + '=' + _encode_uri_component(search_key[key]));
      }
    }
    if (qparts.length) parts.push('?', qparts.join('&'));
  }
  if (hash) parts.push('#', hash);

  return parts.join('')
}


function join(urlstr, options) {
  options = options || {};
  var self = this,
      sources = self[_url_parse_key[9]].split('/'), // self.pathname.split
      ptr     = sources.length - 1,                 // Points to last element
      url     = parse(urlstr),
      targets = url.pathname.split('/'),
      l       = targets.length,
      i,
      frag;

  if (typeof options.query == 'undefined')
    options.query = true;
  if (typeof options.hash == 'undefined')
    options.hash = true;

  for (i=0; i<14; i++) {
    if (i == 9) continue                      // Ignore path
    if (i == 12 && !options.query) continue   // Ignore search parameters
    if (i == 13 && !options.hash) continue    // Ignore url fragment
    if (url[_url_parse_key[i]]) self[_url_parse_key[i]] = url[_url_parse_key[i]];
  }
  if (options.query && url[_url_parse_key[12]]) {  // Copy search parameters
    self[_url_parse_qname[0]] = url[_url_parse_qname[0]];
    self[_url_parse_qname[1]] = url[_url_parse_qname[1]];
  }
  for (i=0; i < l; i++) {
    frag = targets[i];
    if (frag == '.') {
      sources[ptr] = '';
    } else if (frag == '..') {
      sources[--ptr] = '';
    } else if (frag === '') {
      // Ignore blank urlstr
      if (l > 1) {
        // Leading slash clears the URL
        if (!i) {
          sources[0] = frag;
          ptr = 1;
        }
        // Trailing slash is appended
        if (i == l - 1) sources[ptr] = frag;
      }
    } else {
      sources[ptr] = frag;
      if (i < l - 1) ptr++;
    }
  }

  // Set .pathname, .directory, .file.
  var path = self[_url_parse_key[9]] = sources.slice(0, ptr + 1).join('/'),
      parts = path.split(/\//),
      relative = [path];
  if (self[_url_parse_key[12]]) relative.push('?', self[_url_parse_key[12]]);
  if (self[_url_parse_key[13]]) relative.push('#', self[_url_parse_key[13]]);
  self[_url_parse_key[8]] = relative.join('');   // relative
  self[_url_parse_key[10]] = parts.slice(0, parts.length - 1).join('/') + '/';   // directory
  self[_url_parse_key[11]] = parts[parts.length - 1];  // file

  return self
}


function update(args, mode) {
  var self = this,
      search_key = self[_url_parse_qname[0]],
      search_list = self[_url_parse_qname[1]],
      qparts = [],
      modes = {},
      key, val, i, l, hash, search_list_key, result;

  if (mode) {
    // Ensure that mode is a string
    mode = '' + mode;
    // If the mode is like a=add&b=toggle, treat it like URL search params and
    // convert it into a dictionary
    if (mode.match(/[&=]/))
      modes = parse('?' + mode).searchKey;
    // If the mode is just a string like add, del, toggle, apply it to all keys
    else
      for (key in args)
        modes[key] = mode;
  }

  for (key in args) {
    val = args[key];
    if (val === null) {
      search_list[key] = [];
    } else {
      if (!Array.isArray(val)) val = [val];
      if (!modes[key])
        search_list[key] = val;
      else {
        // Ensure that search_list[key] exists
        if (!(key in search_list)) search_list[key] = [];

        // Prepare a hash for lookup
        for (hash={}, i=0, l=val.length; i<l; i++)
          hash[val[i].toString()] = 1;

        // Ensure that mode is a string
        mode = '' + modes[key];

        if (mode.match(/add/i))
          search_list[key] = search_list[key].concat(val);

        // mode=del deletes all matching values
        else if (mode.match(/del/i)) {
          for (result=[], search_list_key=search_list[key], i=0, l=search_list_key.length; i<l; i++) {
            if (!hash[search_list_key[i]])
              result.push(search_list_key[i]);
          }
          search_list[key] = result;
        }

        // mode=toggle deletes matching values, adds the rest
        else if (mode.match(/toggle/i)) {
          for (result=[], search_list_key=search_list[key], i=0, l=search_list_key.length; i<l; i++) {
            if (hash[search_list_key[i]])
              hash[search_list_key[i]] = 2; // Mark it as present
            else
              result.push(search_list_key[i]);
          }
          // Append the unmarked values
          for (val in hash)
            if (hash[val] == 1)
              result.push(val);
          search_list[key] = result;
        }
      }
    }
    if (search_list[key].length === 0) {
      delete search_key[key];
      delete search_list[key];
    } else {
      search_key[key] = search_list[key][search_list[key].length - 1];
    }
  }
  for (key in search_list) {
    val = search_list[key];
    for (i=0, l=val.length; i<l; i++) {
      qparts.push(_encode_uri_component(key) + '=' + _encode_uri_component(val[i]));
    }
  }
  self.search = qparts.join('&');
  return self
}

// jQuery utilities.
// These are NOT jQuery plugins. They accept a $node directly.
// These are NOT exposed as part of the API. Purely internal.

// Return all values that match the selector
// AMONG and UNDER the $node
function findall($node, selector) {
  return $node.filter(selector).add($node.find(selector))
}

// Returns true if data attribute is present
//    But if the value is "false", "off", "n" or "no" in any case, returns false (like YAML)
// Returns default_value if data attribute is missing
function hasdata($node, key, default_value) {
  var val = $node.data(key);
  if (typeof val == 'undefined' || val === false || val === null)
    return default_value
  if (typeof val == 'string' && val.match(/^(false|off|n|no)$/i))
    return false
  return true
}

var container_options = {
  attr: 'href',
  event: 'click change submit',
  selector: '.urlfilter',
  src: 'src'
};
var event_namespace =  '.urlfilter';

function urlfilter(options) {
  var $self = this;
  // If there are no elements in the selection, exit silently
  if ($self.length == 0)
    return
  var doc = $self[0].ownerDocument;
  var settings = $.extend({}, container_options, options || {}, this.dataset);
  var default_remove = settings.remove || hasdata($self, 'remove');
  var events = settings.event.split(/\s+/).map(function (v) { return v + event_namespace }).join(' ');
  // options.location and options.history are used purely for testing
  var loc = settings.location || (doc.defaultView || doc.parentWindow).location;
  var hist = settings.history || (doc.defaultView || doc.parentWindow).history;
  return $self
    .on(events, settings.selector, function (e) {
      var $this = $(this),
          mode = $this.data('mode') || settings.mode,
          target = $this.data('target') || settings.target,
          src = $this.data('src') || settings.src,
          remove = hasdata($this, 'remove', default_remove),
          href;
      if (e.type == 'change' || $(e.target).is(':input:not(:button)')) {
        var key = encodeURIComponent($this.attr('id') || $this.attr('name'));
        var val = encodeURIComponent($this.val());
        href = '?' + key + '=' + val;
      }
      else if (e.type == 'submit' || $(e.target).is('form')) {
        e.preventDefault();
        href = '?' + $this.serialize();
      }
      else if (e.type == 'click') {
        if ($(e.target).is('a'))
          e.preventDefault();
        href = $this.attr(settings.attr);
      } else
        return

      var url = parse(href),
          q = url.searchList;

      function target_url(url) {
        var result = parse(url)
          .join(href, { query: false, hash: false })
          .update(q, mode);
        if (remove) {
          var missing_keys = {};
          for (var key in result.searchKey)
            if (result.searchKey[key] === '')
              missing_keys[key] = null;
          result.update(missing_keys);
        }
        return result.toString()
      }

      // If the target is...       the URL is get/set at
      // ------------------------  ---------------------
      // unspecified (=> window)   location.href
      // 'pushState'               location.href
      // '#'                       location.hash
      // anything else             $(target).data(src)
      if (!target)
        loc.href = target_url(loc.href);
      else if (target == '#')
        loc.hash = target_url(loc.hash.replace(/^#/, ''));
      else if (target.match(/^pushstate$/i))
        hist.pushState({}, '', target_url(loc.href));
      else {
        $(target).each(function () {
          var $target = $(this);
          var url = target_url($target.attr(src));
          $target.attr(src, url).load(url, function () {
            $target.trigger({ type: 'load', url: url });
          });
        });
      }
      $this.trigger({ type: 'urlfilter', url: url });
    })
}

var url = {
  parse: parse,
  unparse: unparse,
  join: join,
  update: update
};

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery.fn, {
    urlfilter: urlfilter
  });
}

/* globals $, _ */
function ajaxchain(request, $self, requests, responses) {
  $self = $self || $('<div>');
  requests = requests || [];
  responses = responses || [];
  if (!('limit' in request))
    request.limit = 10;
  request.limit--;
  $.ajax(request)
    .done(function (response, status, xhr) {
      requests.push(request);
      responses.push(response);
      $self.trigger({ type: 'load', request: request, response: response, xhr: xhr });
      if (request.chain && request.limit > 0) {
        try {
          var updates = request.chain(response, request, xhr);
        } catch (e) {
          $self.trigger({ type: 'error', request: request, xhr: xhr, exception: e });
          // eslint-disable-next-line no-console
          console.warn('$.ajaxchain: chain() exception', e);
        }
        if ($.isPlainObject(updates) && !$.isEmptyObject(updates)) {
          var new_request = $.extend(true, {}, request, updates);
          var next = ajaxchain(new_request, $self, requests, responses);
        }
      }
      if (!next)
        $self.trigger({ type: 'done', request: requests, response: responses });
    })
    .fail(function (xhr, testStatus, error) {
      $self.trigger({ type: 'error', request: request, xhr: xhr });
      $self.trigger({ type: 'done', request: requests, response: responses });
      // eslint-disable-next-line no-console
      console.warn('$.ajaxchain: ajax error', error);
    });
  return $self
}

// Chain through a list of URLs in order
ajaxchain.list = function (urls) {
  return function (response, request) {
    var next = urls.indexOf(request.url) + 1;
    if (next < urls.length)
      return { url: urls[next] }
  }
};

// Used by Twitter, YouTube
// Google:    .cursor('data.pageToken', 'nextPageToken')
// Twitter:   .cursor('data.cursor', 'next_cursor')
// Facebook:  .cursor('url', 'paging.next')
if (typeof _ == 'undefined')
  ajaxchain.cursor = function () {
    throw new Error('ajaxchain.cursor requires lodash')
  };
else
  ajaxchain.cursor = function (target, source) {
    return function (response) {
      var key = _.get(response, source);
      if (key)
        return _.set({}, target, key)
    }
  };

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery, {
    ajaxchain: ajaxchain
  });
}

var template_dropdown = "<% var urlfilterClass = key ? 'urlfilter' : '',\nmultiple = multiple ? 'multiple' : '',\nkey = key ? key : '' %> <select class=\"selectpicker border <%- urlfilterClass %>\" id=\"<%- key %>\" <%-multiple%>></select>";
var template_dropdown_options = "<% _.each(data, function(item) { %> <option value=\"<%- item %>\"><%- item %></option> <% }) %>";
var template_dropdown_object = "<% _.each(data, function(item) { %> <option value=\"<%- item[value_key] %>\" label=\"<%- item[label_key] %>\"><%- item[label_key] %></option> <% }) %>";
var template_error = "<div class=\"alert alert-warning\" role=\"alert\"><p class=\"text-center\"> <%- message %> </p></div>";

var default_templates = Object.freeze({
	template_dropdown: template_dropdown,
	template_dropdown_options: template_dropdown_options,
	template_dropdown_object: template_dropdown_object,
	template_error: template_error
});

var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		Object.keys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	Object.keys(source).forEach(function(key) {
		if (!options.isMergeableObject(source[key]) || !target[key]) {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		} else {
			destination[key] = deepmerge(target[key], source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

var default_options = {
  target: '',
  multiple: false,
  value_key: 'value',
  label_key: 'label'
};

function dropdown(js_options) {
  var self = $(this);
  var options = deepmerge_1(default_options, js_options);

  self.html(_.template(template_dropdown)(options));

  if (options.data) {
    render(options.data);
    // Set the default
    if (options.value)
      self.find('.selectpicker').val(options.value).selectpicker('refresh');
    // trigger 'load' event
    self.trigger({type: 'load'});
  }
  else if (options.url) {
    render(['Loading...']);
    $.ajax(options.url)
      .fail(function(xhr, status, message) {
        // load error template
        self.html(_.template(template_error)({message: message}));
      })
      .done(function(response) {
        render(response);
        self.find('.selectpicker').selectpicker('refresh');
        self.trigger({type: 'load'});
      });
  }

  function render(data) {
    options.data = data;
    if (options.key) {
      // urlfilter
      self.urlfilter({
        selector: 'select.urlfilter',
        target: options.target,
        event: 'change',
        remove: true
      });
    }
    // re-render dropdown template options with fetched data
    var template = typeof data[0] == 'object' ? 'template_dropdown_object' : 'template_dropdown_options';
    self.find('.selectpicker')
      .html(_.template(default_templates[template])(options))
      .selectpicker(options.options);
  }

  return this
}

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery.fn, {
    dropdown: dropdown
  });
}

var _event;
try {
  new Event('click');
  _event = function(name, options) {
    // On Firefox, you needed to send the right event subclass. This is no longer a problem.
    // See https://developer.mozilla.org/en-US/docs/Web/Reference/Events for the list
    // if (name.match(/click$|^mouse|^menu$/)) return new MouseEvent(name, options)
    // else if (name.match(/^key/))            return new KeyboardEvent(name, options)
    // else if (name.match(/^focus|^blur$/))   return new FocusEvent(name, options)
    return new Event(name, options)
  };
} catch (e) {
  // The old fashioned way, for IE
  _event = function(name, options) {
    var evt = document.createEvent('event');
    evt.initEvent(name, options.bubbles, options.cancelable);
    return evt
  };
}

function dispatch(name, options) {
  return this.each(function() {
    this.dispatchEvent(_event(name, $.extend({
      bubbles: true,
      cancelable: true
    }, options)));
  })
}

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery.fn, {
    dispatch: dispatch
  });
}

var template_ = "<div class=\"position-relative\"><div class=\"formhandler\"><div class=\"note\"></div><div class=\"formhandler-table-header d-flex justify-content-between mb-2\"><div class=\"d-flex flex-wrap\"><div class=\"edit\"></div><div class=\"add\"></div><div class=\"count\"></div><div class=\"page\"></div><div class=\"size\"></div></div><div class=\"d-flex\"><div class=\"filters\"></div><div class=\"export\"></div></div></div><div class=\"<%- (options.table == 'grid') ? 'table_grid' : 'table' %>\"></div></div><div class=\"loader pos-cc d-none\"><div class=\"fa fa-spinner fa-spin fa-3x fa-fw\"></div><span class=\"sr-only\">Loading...</span></div></div><div class=\"modal formhandler-table-modal\" id=\"fh-modal-<%- idcount %>\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"fh-label-<%- idcount %>\" aria-hidden=\"true\"><div class=\"modal-dialog modal-sm\" role=\"document\"><div class=\"modal-content\"><form class=\"formhandler-table-modal-form modal-body\"><label id=\"fh-label-<%- idcount %>\" for=\"formhandler-table-modal-value\">Value</label><p><input class=\"form-control\" name=\"filter_input\"></p><div><button type=\"button\" class=\"btn btn-sm btn-secondary mr-1\" data-dismiss=\"modal\">Cancel</button><button type=\"submit\" class=\"btn btn-sm btn-primary mr-1\">Apply filter</button><a class=\"btn btn-sm btn-danger remove-action urlfilter\" data-dismiss=\"modal\" data-target=\"#\" href=\"#\">Remove filter</a></div></form></div></div></div>";
var template_table = "<%\n  var filtered_cols = args['_c'] && args['_c'].length != options.columns.length ?\n                      options.columns.filter(function(col) { return args['_c'].indexOf('-' + col.name) < 0 }) :\n                      options.columns\n  var cols = options.columns.length ? filtered_cols : meta.columns;\n  cols = cols.filter(function(col) { return col.hide !== true})\n  var form_id = idcount\n%> <table class=\"table table-sm table-striped\"><thead> <% _.each(cols, function(colinfo) {\n        col_defaults(colinfo, data)\n        var menu_item = false\n        var col_id = idcount++\n        var qsort = parse('?')\n        var isSorted = _.includes(args['_sort'], colinfo.name) ? {op: '', cls: 'table-primary'} : _.includes(args['_sort'], '-' + colinfo.name) ? {op: '-', cls: 'table-danger'} : {}\n      %> <th class=\"<%- isSorted.cls %>\" data-col=\"<%- colinfo.name %>\"><div class=\"dropdown\"><a href=\"#\" class=\"dropdown-toggle text-nowrap\" id=\"fh-dd-<%- col_id %>\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"> <%- colinfo.title || colinfo.name %> </a><div class=\"dropdown-menu\" aria-labelledby=\"fh-dd-<%- col_id %>\"> <% _.each(colinfo.sort, function(title, op) { menu_item = true\n              qsort = qsort.update({_sort: args['_sort'] || []})\n              if (!_.isEmpty(isSorted))\n                qsort = qsort.update({_sort: [colinfo.name, '-' + colinfo.name]}, 'del')\n              var active = _.includes(args['_sort'], op + colinfo.name) %> <a class=\"dropdown-item urlfilter <%- active ? 'active': '' %>\" href=\"<%- qsort.update({_sort: [op + colinfo.name]}, active ? 'del': 'add').toString() %>\"> <%- title %> </a> <% }) %> <% if (menu_item) { %> <div class=\"dropdown-divider\"></div> <% menu_item = false } %> <% _.each(colinfo.filters, function(title, op) { menu_item = true %> <a class=\"dropdown-item <%= colinfo.name + op in args ? 'active' : '' %>\" href=\"#\" data-op=\"<%- op %>\" data-toggle=\"modal\" data-target=\"#fh-modal-<%- form_id %>\"> <%- title %> </a> <% }) %> <% if (menu_item) {\n              menu_item = false %> <div class=\"dropdown-divider\"></div> <% } %> <% if (colinfo.hideable) { %> <a class=\"dropdown-item urlfilter\" href=\"?_c=-<%- encodeURIComponent(colinfo.name) %>\" data-mode=\"add\">Hide</a> <% } %> </div></div></th> <% }) %> </thead><tbody> <% if (isAdd) { %> <tr class=\"new-row\"> <% _.each(cols, function(colinfo) {\n          if (!colinfo.template) { %> <td data-key=\"<%- colinfo.name %>\"> <% var isEditable = colinfo.editable === undefined ? true : colinfo.editable %> <%= _.template(templates['template_editable'])({isEditable: isEditable, val: undefined}) %> </td> <% } else { %> <td></td> <% } %> <% }) %> </tr> <% } %> <% if (options.rowTemplate) { %> <% _.each(data, function(row, rowIndex) { %> <%= typeof options.rowTemplate == 'function' ? options.rowTemplate({row: row, data: data, index: rowIndex}) : _.template(options.rowTemplate)({row: row, data: data, index: rowIndex}) %> <% }) %> <% } else {%> <% _.each(data, function(row, rowIndex) { %> <tr data-val=\"<%- JSON.stringify(row) %>\" data-row=\"<%- rowIndex %>\"> <% _.each(cols, function(colinfo) { %> <% var fmt = typeof(colinfo.format),\n            val = row[colinfo.name],\n            isEditable = colinfo.editable === undefined ? true : colinfo.editable,\n            disp = fmt == \"function\" ?\n              colinfo.format({name: colinfo.name, value: val, index: rowIndex, row: row, data:data }) :\n            fmt === \"string\" && colinfo.type === \"number\" ?\n              numeral(val).format(colinfo.format) :\n            fmt === \"string\" && colinfo.type === \"date\" ?\n              moment.utc(val).format(colinfo.format):\n              val,\n            col_link\n          %> <% if (!isEdit && colinfo.template) { %> <%= typeof colinfo.template == 'function' ?\n              colinfo.template({name: colinfo.name, value: val, format: disp, link: col_link, index: rowIndex, row: row, data: data}) :\n              _.template(colinfo.template)(({name: colinfo.name, value: val, format: disp, link: col_link, index: rowIndex, row: row, data: data})) %> <% } else if (!isEdit && 'link' in colinfo) { %> <% col_link = typeof colinfo.link == 'function' ?\n              colinfo.link({name: colinfo.name, value: val, format: disp, index: rowIndex, row: row, data: data}) :\n              (typeof colinfo.link == 'string' ?\n                _.template(colinfo.link)({name: colinfo.name, value: val, format: disp, index: rowIndex, row: row, data: data})\n                : colinfo.link)\n                %> <% if (col_link === false) { %> <td><%= disp %></td> <% } else if (col_link && col_link[0] == '?') { %> <td><a class=\"urlfilter\" href=\"<%- col_link %>\"><%= disp %></a></td> <% } else { %> <td><a href=\"<%- col_link %>\" target=\"_blank\"><%= disp %></a></td> <% } %> <% } else if (isEdit && isEditable) { %> <td data-key=\"<%- colinfo.name %>\"> <%= _.template(templates['template_editable'])({isEditable: isEditable, val: val}) %> </td> <% } else { %> <td><a class=\"urlfilter\" href=\"?<%- encodeURIComponent(colinfo.name) %>=<%- encodeURIComponent(val) %>&_offset=\"> <%= disp %> </a></td> <% } %> <% }) %> </tr> <% }) %> <% } %> </tbody></table>";
var template_editable = "<% if (isEditable.input == 'select') { %> <select <% for (key in isEditable.attrs) { %> <%= key + '=\"' + isEditable.attrs[key] + '\"' %> <% } %> class=\"form-control form-control-sm\"><option value=\"\" disabled selected>-- select --</option> <% _.each(isEditable.options, function(item) { %> <option <%- val !== undefined && val === item ? 'selected': null %> value=\"<%- item %>\"> <%- item %> </option> <% }) %> </select> <% } else if (isEditable.input == 'radio') { %> <% _.each(isEditable.options, function(item) { %> <input type=\"radio\" <%- val !== undefined && val === item ? 'checked': null %> value=\"<%- item %>\" <% for (key in isEditable.attrs) { %> <%= key + '=\"' + isEditable.attrs[key] + '\"' %> <% } %> class=\"form-control form-control-sm\"> <%- item %> <br> <% }) %> <% } else { %> <input type=\"<%- isEditable.input || 'text' %>\" value=\"<%- val %>\" <% for (key in isEditable.attrs) { %> <%= key + '=\"' + isEditable.attrs[key] + '\"' %> <% } %> class=\"form-control form-control-sm\"> <% } %> <% if (isEditable.validationMessage) { %> <div class=\"invalid-feedback\"> <%- isEditable.validationMessage %> </div> <% } %>";
var template_page = "<% var page = 1 + Math.floor(meta.offset / meta.limit),\n      last_page = 'count' in meta ? Math.floor((meta.count + meta.limit - 1) / meta.limit) : meta.rows < meta.limit ? page : null,\n      lo = Math.max(page - 2, 1),\n      hi = last_page !== null ? Math.min(last_page, page + 2) : page + 2 %> <ul class=\"pagination pagination-sm mr-2\"><li class=\"page-item <%- page <= 1 ? 'disabled' : '' %>\"><a class=\"page-link\" href=\"?_offset=<%- meta.offset - meta.limit %>\">Previous</a></li> <% if (lo > 1) { %> <li class=\"page-item\"><a class=\"page-link\" href=\"?_offset=\">1</a></li> <% if (lo > 2) { %> <li class=\"page-item disabled\"><a class=\"page-link\" href=\"#\">...</a></li> <% } %> <% } %> <% _.each(_.range(lo, hi + 1), function(pg) { %> <li class=\"page-item <%- pg == page ? 'active' : '' %>\"><a class=\"page-link\" href=\"?_offset=<%- meta.limit * (pg - 1) || '' %>\"> <%- pg %> </a></li> <% }) %> <% if ('count' in meta) { %> <% if (hi + 1 < last_page) { %> <li class=\"page-item disabled\"><a class=\"page-link\" href=\"#\">...</a></li> <% } %> <% if (hi < last_page || lo > hi) { %> <li class=\"page-item\"><a class=\"page-link\" href=\"?_offset=<%- meta.limit * (last_page - 1) %>\"> <%- last_page %> </a></li> <% } %> <% } %> <li class=\"page-item <%- (last_page === null) || (page < last_page) ? '' : 'disabled' %>\"><a class=\"page-link\" href=\"?_offset=<%- meta.offset + meta.limit %>\">Next</a></li></ul>";
var template_size = "<% if (meta.limit) { %> <div class=\"btn-group btn-group-sm mr-2\" role=\"group\"><button id=\"formhandler-size-<%- idcount++ %>\" type=\"button\" class=\"btn btn-light btn-sm dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"> <%- meta.limit %> rows</button><div class=\"dropdown-menu\" aria-labelledby=\"formhandler-size-<%- idcount %>\"> <% _.each(options.sizeValues, function(size) { %> <a class=\"dropdown-item <%- meta.limit == size ? 'active' : '' %> urlfilter\" href=\"?_limit=<%- size %>\"> <%- size %> </a> <% }) %> </div></div> <% } %>";
var template_count = "<% if ('count' in meta) { %> <span class=\"btn btn-sm btn-light mr-2\"> <%- meta.count %> rows</span> <% } %>";
var template_edit = "<button type=\"submit\" class=\"btn btn-success mr-2 btn-sm edit-btn\">Edit</button>";
var template_add = "<button type=\"button\" class=\"btn btn-success mr-2 btn-sm add-btn\">Add</button>";
var template_export = "<div class=\"btn-group btn-group-sm\" role=\"group\"><button id=\"formhandler-export-<%- idcount++ %>\" type=\"button\" class=\"btn btn-light btn-sm dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">Export as</button><div class=\"dropdown-menu dropdown-menu-right\" aria-labelledby=\"formhandler-export-<%- idcount %>\"> <% _.each(options.exportFormats, function(label, key) { %> <a class=\"dropdown-item\" href=\"<%- parse(options.src).update(args).update({_format: key}) %>\"> <%- label %> </a> <% }) %> </div></div>";
var template_filters = "<div class=\"p-1\"><%\n  var qparts = parse('?')\n  _.each(args['_c'], function(col_name) {\n    qparts.update({_c: col_name}, 'add')\n    var hide_col = col_name[0] == '-'\n    var display_name = hide_col ? col_name.slice(1) : col_name %> <a href=\"?_c=<%- encodeURIComponent(col_name) %>\" data-mode=\"del\" class=\"badge badge-pill <%- hide_col ? 'badge-dark' : 'badge-danger' %> urlfilter\" title=\"<%- hide_col ? 'Show' : 'Hide' %> column <%- display_name %>\"> <%- display_name %> </a> <% })\n  _.each(args, function(list_values, key) {\n    if (key.charAt(0) !== '_' && key !== 'c') {\n      _.each(args[key], function(col_name) {\n        var update = {}\n        update[key] = col_name\n        qparts.update(update, 'add') %> <a href=\"?<%- encodeURIComponent(key) %>=<%- encodeURIComponent(col_name) %>\" data-mode=\"del\" class=\"badge badge-pill badge-dark urlfilter\" title=\"Clear <%- key %> filter\"> <%- key %> = <%- col_name %> </a> <% })\n    }\n  })\n  qparts = qparts.toString()\n  if (qparts && qparts != '?') { %> <a href=\"?<%- qparts.slice(1) %>\" class=\"badge badge-pill badge-danger urlfilter\" data-mode=\"del\" title=\"Clear all filters\">×</a> <% } %> </div>";
var template_error$1 = "<div class=\"alert alert-warning alert-dismissible\" role=\"alert\"> <%- message %> <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-label=\"Close\"><span aria-hidden=\"true\">×</span></button></div>";
var template_table_grid = "<%\n  var filtered_cols = args['_c'] && args['_c'].length != options.columns.length ?\n                      options.columns.filter(function(col) { return args['_c'].indexOf('-' + col.name) < 0 }) :\n                      options.columns\n  var cols = options.columns.length ? filtered_cols : meta.columns\n  var form_id = idcount, img\n  if (options.rowTemplate) {\n    _.each(data, function(row, rowIndex) { %> <%= typeof options.rowTemplate == 'function' ? options.rowTemplate({row: row, index: rowIndex, data: data}) : _.template(options.rowTemplate)({row: row, data: data, index: rowIndex}) %> <% })\n} else { %> <div class=\"formhandler-grid row\"> <% _.each(data, function(row, rowIndex) { %> <div class=\"col-sm-3 <%= options.classes || 'formhandler-grid-cell d-inline-block p-3 box-shadow' %>\"><div class=\"thumbnail\"> <% img = options.icon ? ((typeof(options.icon) == 'function' ? options.icon({row: row, data: data, index: rowIndex}) : options.icon)) : 'fa fa-home' %> <% if (img.indexOf('fa ') >= 0) { %> <i class=\"<%= img %>\"></i> <% } else { %> <img class=\"img img-responsive\" src=\"<%= img %>\"> <% } %> <div class=\"caption\"> <% _.each(cols, function(colinfo) {\n              var fmt = typeof(colinfo.format),\n                  val = row[colinfo.name],\n                  disp = (fmt == \"function\" ? colinfo.format({index: rowIndex, name: colinfo.name, value: val, row: row, data:data }) :\n                          fmt === \"string\" && colinfo.type === \"number\" ? numeral(val).format(colinfo.format) :\n                          fmt === \"string\" && colinfo.type === \"date\" ? moment.utc(val).format(colinfo.format) :\n                          val) %> <div><strong><%= colinfo.name %></strong>: <% if ('link' in colinfo) { %> <% var col_link = typeof colinfo.link == 'function' ?\n                      colinfo.link({row: row, value: val, index: rowIndex, name: colinfo.name, data: data, format: disp}) :\n                      _.template(colinfo.link)({row: row, value: val, index: rowIndex, name: colinfo.name, data: data, format: disp}) %> <% if (col_link === false) { %> <%= disp %> <% } else if (col_link && col_link[0] == '?') { %> <a class=\"urlfilter\" href=\"<%- col_link %>\"><%= disp %></a> <% } else { %> <a href=\"<%- col_link %>\" target=\"_blank\"><%= disp %></a> <% } %> <% } else { %> <a class=\"urlfilter\" href=\"?<%- encodeURIComponent(colinfo.name) %>=<%- encodeURIComponent(val) %>&_offset=\"> <%= disp %> </a> <% } %> </div> <% }) %> </div></div></div> <% }) %> </div> <% } %>";

var default_templates$1 = Object.freeze({
	template_: template_,
	template_table: template_table,
	template_editable: template_editable,
	template_page: template_page,
	template_size: template_size,
	template_count: template_count,
	template_edit: template_edit,
	template_add: template_add,
	template_export: template_export,
	template_filters: template_filters,
	template_error: template_error$1,
	template_table_grid: template_table_grid
});

// Import HTML sections as variables using rollup-plugin-htmlparts.js.

// Render components in this order. The empty component is the root component.
var components = ['', 'table', 'edit', 'add', 'page', 'size', 'count', 'export', 'filters', 'error', 'table_grid'];
var default_options$1 = {
  table: true,
  edit: false,
  add: false,
  page: true,
  pageSize: 100,
  size: true,
  sizeValues: [10, 20, 50, 100, 500, 1000],
  count: true,
  export: true,
  exportFormats: {
    xlsx: 'Excel',
    csv: 'CSV',
    json: 'JSON',
    html: 'HTML'
  },
  filters: true,
  onhashchange: true
};
var meta_headers = ['filters', 'ignored', 'excluded', 'sort', 'offset', 'limit', 'count'];

var default_filters = {
  text: { '': 'Equals...', '!': 'Does not equal...', '~': 'Contains...', '!~': 'Does not contain...' },
  number: { '': 'Equals...', '!': 'Does not equal...', '<': 'Less than...', '>': 'Greater than...' },
  date: { '': 'Equals...', '!': 'Does not equal...', '<': 'Before...', '>': 'After...' }
};

// Set default values for column specifications
// function col_defaults(colinfo, data) {
function col_defaults(colinfo) {
  // Sort defaults
  if (!('sort' in colinfo) || colinfo.sort === true)
    colinfo.sort = { '': 'Sort ascending', '-': 'Sort descending' };
  else if (typeof colinfo.sort != 'object')
    colinfo.sort = {};

  // Type defaults
  colinfo.type = colinfo.type || 'text';

  // Filters defaults
  if (!('filters' in colinfo) || (colinfo.filters === true))
    colinfo.filters = default_filters[colinfo.type];

  // Hideable defaults
  if (!('hideable' in colinfo))
    colinfo.hideable = true;

  // Hide defaults
  if (!('hide' in colinfo))
    colinfo.hide = false;
}


function formhandler(js_options) {
  if (!js_options)
    js_options = {};

  this.each(function () {
    var $this = $(this);
    // Convert all .urlfilter classes into url filters that update location.hash
    $this.urlfilter({
      selector: '.urlfilter, .page-link',
      target: '#',
      remove: true                          // auto-remove empty values
    });

    // Pre-process options
    var options = $.extend({}, default_options$1, js_options, $this.data());

    if (!options.columns)
      options.columns = [];
    else if (typeof options.columns == 'string')
      options.columns = _.map(options.columns.split(/\s*,\s*/), function (col) { return { name: col } });

    // Compile all templates
    var template = {};
    _.each(components, function (name) {
      var tmpl = options[name ? name + 'Template' : 'template'] || default_templates$1['template_' + name] || 'NA';
      template[name] = _.template(tmpl);
    });

    function draw_table(data, args, meta) {
      // Add metadata
      meta.rows = data.length;
      meta.columns = data.length ? _.map(data[0], function (val, col) { return { name: col } }) : [];

      // If any column name is '*', show all columns
      var star_col = _.find(options.columns, function (o) { return o['name'] === '*' });
      if (star_col) {
        var action_header_cols = _.cloneDeep(meta.columns);
        _.map(options.columns, function (option_col) {
          var found = _.find(meta.columns, function (o) { return o['name'] === option_col.name });
          if (!found && option_col.name !== '*')
            action_header_cols.push(option_col);
        });

        action_header_cols = _.map(action_header_cols, function (col) {
          var options_col = _.find(options.columns, function (o) { return o['name'] === col.name });
          return options_col ? options_col : $.extend({}, star_col, col)
        });
      }

      options.columns = action_header_cols ? action_header_cols : options.columns;

      // Render all components into respective targets
      var template_data = {
        data: data,
        meta: meta,
        args: args,
        options: options,
        idcount: 0,
        parse: parse,
        col_defaults: col_defaults,
        isEdit: false,
        isAdd: false,
        templates: default_templates$1
      };
      // Store template_data in $this
      $this.data('formhandler', template_data);

      _.each(components, function (name) {
        render_template(name, template_data, options, $this, template);
      });
      if (options.add)
        addHandler($this, template_data, options, template);
      if (options.edit)
        editHandler($this, template_data, options, template);
    }

    function render() {
      var url_args = parse(location.hash.replace(/^#/, '')).searchList;
      url_args = namespace(url_args, options.name);
      // Create arguments passed to the FormHandler. Override with the user URL args
      var args = _.extend({
        c: options.columns.map(function (d) { return d.name }),
        _limit: options.pageSize,
        _format: 'json',
        _meta: 'y'
      }, url_args);
      $('.loader', $this).removeClass('d-none');

      function done(data, status, xhr) {
        var meta = {};
        _.each(meta_headers, function (header) {
          var val = xhr ? xhr.getResponseHeader('Fh-Data-' + header) : null;
          if (val !== null)
            meta[header] = JSON.parse(val);
        });
        if (typeof options.transform == 'function') {
          var result = options.transform({ data: data, meta: meta, options: options, args: args }) || {};
          data = 'data' in result ? result.data : data;
          meta = 'meta' in result ? result.meta : meta;
        }

        // To support data-src that doesn't poin to formhandler url pattern
        if (_.isEmpty(meta) && options.page && options.size) {
          meta['offset'] = args._offset ? parseInt(args._offset) : 0;
          meta['limit'] = parseInt(args._limit);
          meta['count'] = data.length;
          data = datafilter(data, args);
        }

        draw_table(data, args, meta);
        $this.trigger({ type: 'load', formdata: data, meta: meta, args: args, options: options });
      }

      if (options.data && typeof (options.data) == 'object') {
        options.edit = false;
        options.add = false;
        done(options.data);
      }
      else {
        $.ajax(options.src, {
          dataType: 'json',
          data: args,
          traditional: true
        }).done(done)
          .always(function () { $('.loader', $this).addClass('d-none'); })
          .fail(failHandler.bind(this, $this, template));
      }
    }

    modalHandler($this);

    actionHandler($this, options, template);

    // Re-render every time the URL changes
    if (options.onhashchange)
      $(window).on('hashchange', render);
    // Initialize
    render();
  });

  return this
}

function modalHandler($this) {
  //  Handle modal dialog
  $this
    .on('shown.bs.modal', '.formhandler-table-modal', function (e) {
      var $el = $(e.relatedTarget);
      var template_data = $this.data('formhandler');
      var op = $el.data('op');
      var col = $el.closest('[data-col]').data('col');
      var val = '';
      // If there is a value, show it, and allow user to remove the filter
      if (template_data.args[col + op]) {
        val = template_data.args[col + op].join(',');
        $('.remove-action', this).attr('href', '?' + col + op + '=').show();
      } else
        $('.remove-action', this).hide();
      $('input', this).val(val).attr('name', col + op).focus();
      $('label', this).text($el.text());
    })
    .on('submit', 'form', function (e) {
      e.preventDefault();
      var filter = parse('?' + $(this).serialize()).searchKey;
      $(this).closest('.formhandler-table-modal').modal('hide');
      window.location.hash = '#' + parse(location.hash.replace(/^#/, '')).update(filter);
    });
}

function render_template(name, data, options, $this, template) {
  // Disable components if required. But root component '' is always displayed
  if (name && !options[name])
    return

  var target;
  // The root '' component is rendered into $this.
  if (!name)
    target = $this;
  else {
    // Rest are rendered into .<component-name> under $this

    if (options[name] == 'grid') name = 'table_grid';
    var selector = options[name + 'Target'] || '.' + name;
    target = $(selector, $this);
    // But if they don't exist, treat the selector as a global selecctor
    if (target.length == 0)
      target = $(selector);
  }
  target.html(template[name](data));
}


function addHandler($this, template_data, options, template) {

  $('.add button', $this)
    .on('click', function () {
      var add_btn = $('.add button', $this);
      var edit_btn = $('.edit button', $this);
      if (add_btn.html().toLowerCase() == 'save') {
        add_btn.html('Add');
        edit_btn.prop('disabled', false);
        var columns_data = $('.new-row td[data-key]');

        $('.loader', $this).removeClass('d-none');
        var data = {};

        $.each(columns_data, function (key, column) {
          data[column.getAttribute('data-key')] = $(column).children().val();
        });
        // if no changes made to new empty celled row, rerender the table.
        if (!_.some(data)) {
          $('.loader', $this).addClass('d-none');
          template_data.isAdd = false;
          render_template('table', template_data, options, $this, template);
          return
        }

        $.ajax(options.src, {
          method: 'POST',
          dataType: 'json',
          data: data
        }).done(function () {
          template_data.data.unshift(data);
          template_data.isAdd = false;
          render_template('table', template_data, options, $this, template);
          if (options.add.done) options.add.done();
        }).always(function () { $('.loader', $this).addClass('d-none'); })
          .fail(failHandler.bind(this, $this, template));
      } else if (add_btn.html().toLowerCase() == 'add') {
        add_btn.html('Save');
        edit_btn.prop('disabled', true);
        template_data.isAdd = true;
        render_template('table', template_data, options, $this, template);
        add_edit_events($this, add_btn);
      }
    });
}

function editHandler($this, template_data, options, template) {
  $('.edit button', $this)
    .on('click', function () {
      var edit_btn = $('.edit button', $this);
      var add_btn = $('.add button', $this);
      if (edit_btn.html().toLowerCase() == 'save') {
        var edited_rows = $('.edited-row');
        if (edited_rows.length > 0)
          $('.loader', $this).removeClass('d-none');

        var all_ajax = [];
        var allRowsValid = true;
        $.each(edited_rows, function (key, edited_row) {
          var data = JSON.parse(edited_row.getAttribute('data-val'));
          var rowIndex = edited_row.getAttribute('data-row');
          for (key in data) {
            // TODO: refactor to identify editable columns other than using data-key attrs on <td> tag
            $('td[data-key="' + (remove_quotes(key)) + '"] :input', edited_row).each(function() {
              if (this.checkValidity()) {
                $(this).removeClass('is-invalid');
                data[key] = template_data['data'][rowIndex][key] = $(this).val();
              } else {
                $(this).addClass('is-invalid');
                allRowsValid = false;
              }
            });
          }

          all_ajax.push(
            $.ajax(options.src, {
              method: 'PUT',
              dataType: 'json',
              data: data
            }).fail(failHandler.bind(this, $this, template))
              .always(function () {
                $('.loader', $this).addClass('d-none');
                if (options.add.editFunction) options.add.editFunction();
              })
          );
        });

        if (!allRowsValid) return
        $.when.apply($, all_ajax).then(function () {
          $('.loader', $this).addClass('d-none');
          edit_btn.html('Edit'); // TODO: remove hardcoding of name Edit
          add_btn.prop('disabled', false);
          if (options.edit.done) options.edit.done();
        });

        template_data.isEdit = false;
        render_template('table', template_data, options, $this, template);
      } else if (edit_btn.html().toLowerCase() == 'edit') {
        edit_btn.html('Save'); // TODO: remove hardcoding of name Save
        add_btn.prop('disabled', true);
        template_data.isEdit = true;
        render_template('table', template_data, options, $this, template);
        add_edit_events($this, edit_btn);
        $this.trigger({ type: 'editmode' });
      }
    });
}

function actionHandler($this, options, template) {
  var default_actions = {
    'delete': function (arg) {
      return $.ajax(options.src, { method: 'DELETE', dataType: 'json', data: arg.row })
        .done(function () { $('tr[data-row="' + arg.index + '"]', $this).remove(); })
    }
  };
  $this.on('click', '[data-action]', function () {
    var arg = {
      row: $(this).closest('[data-val]').data('val'),
      index: $(this).closest('[data-row]').data('row'),
      notify: notify.bind(this, $this, template)
    };
    var action = $(this).data('action');

    var method = (options.actions && (options.actions.filter(function (each_action) { return action in each_action }).length > 0))
      ? options.actions.filter(function (each_action) { return action in each_action })[0][action]
      : default_actions[action];

    var deferred = method(arg);
    if (deferred && deferred.always) {
      $('.loader', $this).removeClass('d-none');
      deferred
        .always(function () { $('.loader', $this).addClass('d-none'); })
        .fail(failHandler.bind(this, $this, template));
    }
  });
}


function remove_quotes(str) {
  return str.toString().replace(/["']/g, '')
}

function notify($this, template, message) {
  var $note = $('.note', $this);
  if (!$note.length)
    $note = $('<div class="note"></div>').appendTo($this);
  $note.html(template['error']({ message: message }));
}

function failHandler($this, template, xhr, status, message) {
  var error = status + ': ' + message;
  if (xhr.readyState == 0)
    error += ' (cannot connect to server)';
  notify($this, template, error);
}


function add_edit_events($this, save_btn) {
  $('tbody :input', $this)
    // When the user types something, mark the row as changed
    .on('change', function () {
      $(this).parents('tr').addClass('edited-row');
    })
    // When the user presses Enter, click on the "Save" button
    .on('keypress', function (e) {
      if (e.keyCode == 13) {
        $(this).blur();      // Remove focus so that change / .edited-row is triggered
        save_btn.trigger('click');
      }
    })
    // Focus on the first element
    .eq(0).focus();
}

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery.fn, {
    formhandler: formhandler
  });
}

var container_options$1 = {
  selector: '[data-toggle="highlight"]',
  target: '.highlight-target',
  mode: 'hover',
  classes: 'active'
};

function highlight(options) {
  this.each(function() {
    var settings = $.extend({}, container_options$1, options, this.dataset);
    var container = this;
    // Loop through all triggers in the container. This may include the container itself
    findall($(this), settings.selector).each(function () {
      var opts = $.extend({}, settings, this.dataset);
      var $this = $(this).off('.g1.highlight');
      var event = opts.mode == 'click' ? 'click.g1.highlight' : 'mouseenter.g1.highlight mouseleave.g1.highlight';
      $this.on(event, function () {
        // When the trigger is triggered, toggle the target classes and fire a highlight event
        var target = $(opts.target, container).toggleClass(opts.classes);
        $this.trigger({ type: 'highlight', target: target });
      });
    });
  });
  return this
}

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery.fn, {
    highlight: highlight
  });
}

function leaflet_topojson(json) {
  if (json.type === 'Topology')
    for (var key in json.objects)
      L.GeoJSON.prototype.addData.call(this, topojson.feature(json, json.objects[key]));
  else
    L.GeoJSON.prototype.addData.call(this, json);
}

if (typeof L !== 'undefined')
  L.TopoJSON = L.GeoJSON.extend({
    addData: leaflet_topojson
  });

// data- attribute to store the last performed search
var _lastsearch_attr = 'search-last';
// data- attribute to store granular search results
var _search_results = 'search-results';

var container_options$2 = {
  selector: '[data-search]',
  hideClass: '',
  showClass: '',
  transform: 'strip',
  change: 'words',
};

function search(options) {
  var settings = $.extend({}, container_options$2, options, this.data());
  this
    .off('.g.search')
    .on('keyup.g.search change.g.search', settings.selector, run_search)
    .on('refresh.g.search', refresh)
    .on('search.g.search', function (e) {
      refresh(e);
      run_search(e);
    });
  // If the container *IS* the trigger, run search
  this.filter(settings.selector)
    .on('keyup.g.search change.g.search', run_search);
  return this

  // Extract & transform search strings. Cache in input's dataset.search_results
  // Return the search strings.
  function refresh(e) {
    var opts = $.extend({}, settings, e.target.dataset);
    var search_text = opts.search == '@text' ?
      function (el) { return el.textContent } :
      function (el) { return el.getAttribute(opts.search) };
    var transform = search.transforms[opts.transform];
    var result = $(opts.target).map(function() {
      var s = search_text(this);
      return { el: $(this), original: s, text: transform(s), show: true }
    }).get();
    $(e.target).data(_search_results, result)
      .removeData(_lastsearch_attr);
    return result
  }

  function run_search(e) {
    var opts = $.extend({}, settings, e.target.dataset);
    var $el = $(e.target);
    var out = {
      type: 'shown.g.search',
      searchText: $el.val()
    };
    out.search = search.changes[opts.change](search.transforms[opts.transform](out.searchText));
    var lastsearch = $el.data(_lastsearch_attr);
    if (lastsearch == out.search)
      return
    $el.data(_lastsearch_attr, out.search);

    var hidecls = opts.hideClass,
        showcls = opts.showClass,
        re = new RegExp(out.search || '.*');
    out.results = $el.data(_search_results) || refresh(e);
    out.matches = out.results.length;
    out.results.forEach(function (cell) {
      var show = cell.text.match(re);
      if (show !== cell.show) {
        if (hidecls) cell.el[!show ? 'addClass' : 'removeClass'](hidecls);
        if (showcls) cell.el[show ? 'addClass' : 'removeClass'](showcls);
        cell.show = show;
      }
      if (!show) out.matches--;
    });
    $el.trigger(out);
  }
}

search.transforms = {
  strip: function (s) { return (s || '').toLowerCase().replace(/\s+/g, ' ').replace(/^ /, '').replace(/ $/, '') }
};
search.changes = {
  words: function (s) { return s.replace(/\s+/g, '.*') }
};

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery.fn, {
    search: search
  });
}

function template(data, options) {
  options = options || {};
  var selector = options.selector || this.data('selector') || 'script[type="text/html"]';

  // Pre-create the template rendering function
  // Store this in .data('template.function')
  findall(this, selector).each(function () {
    var $this = $(this);
    // If we want to dispose the last target, just dispose it.
    if (data === 'dispose') {
      var $oldtarget = $this.data(_prev_created);
      if ($oldtarget)
        $oldtarget.remove();
      return $this.trigger({
        type: 'template',
        templatedata: data,
        target: $oldtarget
      })
    }
    var renderer = $this.data(_renderer);
    // If there's no template function cached, cache it
    if (!renderer) {
      var src = $this.attr('src');
      if (src) {
        // If the AJAX load succeeds, render the loaded template
        // Else render the contents, with an additional xhr variable
        $.get(src)
          .done(function (html) { make_template($this, html, data, options); })
          .fail(function (xhr) {
            data.xhr = xhr;
            make_template($this, $this.html(), data, options);
          });
      } else
        // If no src= is specified, just render the contents
        make_template($this, $this.html(), data, options);
    } else
      // If the renderer is already present, just use it
      renderer(data, options);
  });
  return this
}

var _renderer = 'template.render';
var _prev_created = 'template.prev_created';

// Bind a template renderer to the node $this.data('template.render')
// This renderer function accepts (data, options) and creates
//    - runs the html template, parses the result, and create a target node
//    - appends the target node after $this (clearing any previous target nodes)
//    - stores the target node in $this.data('template.target')
//    - triggers a template event (with .templatedata, .target)
//    - returns the target node
function make_template($this, html, data, default_options) {
  var compiled_template = _.template(html);
  var $created;
  function renderer(data, options) {
    html = compiled_template(data);
    // Get options. DOM data-* over-rides JS options
    var append = $this.data('append') || (options ? options.append : default_options.append);
    var target = $this.data('target') || (options ? options.target : default_options.target);
    var engine = $this.data('engine') || (options ? options.engine : default_options.engine);
    if (!engine || typeof engine == 'string')
      engine = template.engines[engine] || template.engines['default'];
    // If we're appending the contents, just add the text
    if (append) {
      $created = $($.parseHTML(html));
      // If we're appending to a target node, just append to it.
      if (target)
        $(target).append($created);
      // If no target node, add BEFORE template. Future appends will be in sequence
      else
        $this.before($created);
    }
    // If we're not appending, replace the contents using the renderer
    else {
      // The engine must return the created nodes. See template.engines spec below
      $created = engine($this, target, html);
      // Store the created nodes for future reference. See template.engines spec below
      $this.data(_prev_created, $created);
    }
    // Trigger the template event. Use "templatedata" since ".data" is reserved
    $this.trigger({ type: 'template', templatedata: data, target: $created });
    return $created
  }
  $this.data(_renderer, renderer);
  return renderer(data)
}


// $.fn.template.engines is a registry of rendering engines. Each entry is a
// function that accepts 3 parameters:
//    $this: the <script> element
//    target: the target selector or node to render into. May be undefined
//    html: the HTML to render at the target (or around $this if target is missing)
// It returns the created nodes as a jQuery object. This is used in 2 ways:
//    - the template event.target attribute is this return value
//    - $this.data(_prev_created) is set to this return value
template.engines = {};

// The default engine uses jQuery
template.engines['default'] = template.engines['jquery'] = function ($this, target, html) {
  // Parse the template output and create a node collection
  // $.parseHTML ensures that "hello" is parsed as HTML, not a selector
  var $target = $($.parseHTML(html));
  // If target exists, replace the HTML. Otherwise, create new nodes before the template.
  if (target)
    $(target).html($target);
  else {
    // Remove any previous targets and re-create the output
    var $oldtarget = $this.data(_prev_created);
    if ($oldtarget)
      $oldtarget.remove();
    $this.before($target);
  }
  return $target
};

/* globals morphdom */
template.engines['vdom'] = function ($this, target, html) {
  // If no target is specified, use the previous target, if any
  target = target || $this.data(_prev_created);
  // If a target is specified, wrap the HTML with the target node.
  // For example, <div id="target">...</div> will wrap the HTML with
  // <div id="target"></div>
  var $target, tag_open, tag_close;
  if (target) {
    $target = $(target);
    var node = $target.get(0);
    tag_open = '<' + node.nodeName;
    $.each(node.attributes, function () {
      tag_open += ' ' + this.name + '=' + this.value;
    });
    tag_open += '>';
    tag_close = '</' + node.nodeName + '>';
  }
  // If a target is not specified, Create the target node before the template.
  // Wrap the HTML and the node with <div> to ensure that it's a single node.
  // Morphdom requires a single node.
  else {
    tag_open = '<div>';
    tag_close = '</div>';
    $target = $(tag_open + tag_close).insertBefore($this);
  }
  $target.each(function () {
    morphdom(this, tag_open + html + tag_close);
  });
  return $target
};

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery.fn, {
    template: template
  });
}

function array_eq(a, b) {
  return a && b && a.length === b.length && a.every(function (v, i) { return v === b[i] })
}

function urlchange() {
  var $self = this;
  // $self / this is typically a window, but could also be an iframe. Use its location
  var loc = $self.get(0).location;
  var oldurl, oldpath, oldhash = {};
  return $self.on('hashchange.urlchange', function () {
    var url = parse(loc.hash.replace(/^#/, ''));
    var change = {};
    // Parse keys in old & new URL hash. Trigger "#?<key>" if a key has changed
    for (var key in $.extend({}, url.searchList, oldhash)) {
      var vals = url.searchList[key] || [];
      var old = oldhash[key] || [];
      if (!array_eq(vals, old)) {
        var val = vals.length > 0 ? vals[0] : '';
        $self.trigger({ type: '#?' + key, hash: url, vals: vals, old: oldurl }, val);
        oldhash[key] = change[key] = vals;
      }
    }
    // If the path has changed, trigger a "#/" event
    if (oldpath != url.pathname) {
      $self.trigger({ type: '#/', hash: url, old: oldurl }, url.pathname);
      change['/'] = oldpath = url.pathname;
    }
    // If any part of the hash has changed, trigger a "#?"" event with all info
    if (!$.isEmptyObject(change)) {
      $self.trigger({ type: '#', hash: url, change: change, old: oldurl }, url);
    }
    oldurl = url;
  }).trigger('hashchange')
}

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery.fn, {
    urlchange: urlchange
  });
}

function translate(options) {
  options = options || {};
  var self = this;
  self.each(function () {
    var $this = $(this);
    var source = $this.attr('lang') || options.source || '';
    var target = $this.attr('lang-target') || options.target;
    if (!target)
      throw new Error('$.translate has no target')
    if (target == source)
      return
    var nodes = [], original = [], q = [], node;
    var walk = document.createTreeWalker(this, NodeFilter.SHOW_TEXT, null, false);
    while (node = walk.nextNode()) {
      var text = node.textContent;
      var trimmed = $.trim(text);
      if (trimmed) {
        nodes.push(node);
        original.push(text);
        q.push(trimmed);
      }
    }
    var request = { q: q, source: source, target: target };
    $.ajax({
      url: $this.attr('lang-url') || options.url || 'translate',
      data: request,
      traditional: true
    }).done(function (response) {
      response.forEach(function (d, i) {
        d.node = nodes[i];
        d.node.textContent = original[i].replace(d.q, d.t);
      });
      $this.trigger({ type: 'translate', translate: response });
    }).fail(function (xhr, testStatus, error) {
      $this.trigger({ type: 'error', request: request, xhr: xhr });
      // eslint-disable-next-line no-console
      console.warn('$.translate: error', error);
    });
  });
  return this
}

if (typeof jQuery != 'undefined') {
  jQuery.extend(jQuery.fn, {
    translate: translate
  });
}

// export item into the g1.* namespace

exports.version = version;
exports.datafilter = datafilter;
exports.fuzzysearch = fuzzysearch;
exports.sanddance = sanddance;
exports.scale = scale;
exports.types = types;
exports.url = url;

Object.defineProperty(exports, '__esModule', { value: true });

})));
